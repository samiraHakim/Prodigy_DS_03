# -*- coding: utf-8 -*-
"""Prodigy_DS_Task03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VEnEYOkMJ8rDILEsgrp-pOBWigRSTo2a

**Task03-Build a decision tree classifier to predict whether a customer will purchase a product or service based on their demographic and behavioral data. Use a dataset such as the Bank Marketing dataset from the UCI Machine Learning Repository.**
"""

# Commented out IPython magic to ensure Python compatibility.
# importing libraries
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import pandas as pd

df=pd.read_csv('/content/train.csv')
df.head()

df.info()

df.describe()

#Handling Missing Values in Numerical Columns
df['LoanAmount'] = df['LoanAmount'].fillna(df['LoanAmount'].mean())
df['Loan_Amount_Term'] = df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mean())
df['Credit_History'] = df['Credit_History'].fillna(df['Credit_History'].mean())
df['Gender'] = df['Gender'].fillna(df['Gender'].mode()[0])
df['Married'] = df['Married'].fillna(df['Married'].mode()[0])
df['Dependents'] = df['Dependents'].fillna(df['Dependents'].mode()[0])
df['Self_Employed'] = df['Self_Employed'].fillna(df['Self_Employed'].mode()[0])
df.isnull().sum()

#columns with their values -
cols=df.describe(include="O").columns
for i in cols:
    print("Distinct_values :\n 'column_name' =",i)
    print(df[i].unique())
    print("")

"""**Segregating Numerical and Categorical Attributes**"""

data_cat = df.select_dtypes('object')
data_num = df.select_dtypes(exclude='object')


data_cat.head()

data_num.head()

"""**EDA**"""

#Loan Approval Count by Property Area
import seaborn as sns
plt.figure(figsize=(12 , 7))
sns.countplot(x='Loan_Status', hue='Property_Area', data=df)
plt.show()

# Plot histogram for gender distribution
sns.histplot(data=df, x='Gender', hue='Gender', multiple='stack', palette={'Male': 'cornflowerblue', 'Female': 'orange'}, discrete=True)
plt.show()

plt.figure(figsize=(12 , 7))
sns.countplot(x='Loan_Status' , hue="Self_Employed", data=df)
plt.show()

plt.figure(figsize=(12 , 7))
sns.countplot(x='Loan_Status',hue='Married', data=df)
plt.show()

#Distribution of Dependents
s=df['Dependents'].value_counts()/df['Dependents'].value_counts().sum()*100
plt.pie(s.values,labels=s.index,autopct='%1.1f%%')
plt.show()

sns.countplot(x='Education',hue='Gender',data=df)
# majority are Graduate

# numerical data
sns.distplot(df['CoapplicantIncome'])

sns.distplot(df['LoanAmount'])

#created new column
df['Total_income'] = df['ApplicantIncome']+df['CoapplicantIncome']
df.head()

#log transformation
import numpy as np
df['ApplicantIncome'] = np.log(df['ApplicantIncome'])
df['ApplicantIncome'] = np.exp(df['ApplicantIncome'])
df['CoapplicantIncome'] = np.log(df['CoapplicantIncome'])
df['CoapplicantIncome'] = np.exp(df['CoapplicantIncome'])

df['LoanAmount'] = np.log(df['LoanAmount'])
df['Loan_Amount_Term'] = np.log(df['Loan_Amount_Term'])
df['ApplicantIncomeLog'] = np.log(df['ApplicantIncome'])
df['CoapplicantIncomeLog'] = np.log(df['CoapplicantIncome'])
df['LoanAmountLog'] = np.log(df['LoanAmount'])
df['Loan_Amount_Term_Log'] = np.log(df['Loan_Amount_Term'])
df['Total_Income_Log'] = np.log(df['Total_income'])
df.head()

cols = ['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Total_income', 'Loan_ID', 'CoapplicantIncomeLog']
df = df.drop(columns = cols, axis = 1)
df.head()

corr = df.corr()
plt.figure(figsize=(15,10))
sns.heatmap(corr, annot = True, cmap = 'crest',)

df

#handling categorical data
d1 = pd.get_dummies(df['Gender'], drop_first= True)
d2 = pd.get_dummies(df['Married'], drop_first= True)
d3 = pd.get_dummies(df['Dependents'], drop_first= True)
d4 = pd.get_dummies(df['Education'], drop_first= True)
d5 = pd.get_dummies(df['Self_Employed'], drop_first= True)
d6 = pd.get_dummies(df['Property_Area'], drop_first= True)



df1 = pd.concat([df, d1, d2, d3, d4, d5, d6], axis = 1)
df=df1

cols = ['Gender', 'Married', "Dependents", "Education", "Self_Employed", 'Property_Area']
df = df.drop(columns=cols, axis=1)
df.head()

df.info()

# specify input and output attributes
x = df.drop(columns=['Loan_Status'], axis=1)
y = df['Loan_Status']
x

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.25, random_state = 42)

# decision tree classifier
from sklearn.tree import DecisionTreeClassifier
model = DecisionTreeClassifier()
model.fit(x_train, y_train)
print("Accuracy is", model.score(x_test, y_test)*100)

# Predict the target values on the test set
y_pred = model.predict(x_test)
y_pred

from sklearn.metrics import classification_report
# Print a classification report
print(classification_report(y_test, y_pred))

from sklearn.metrics import confusion_matrix
# Convert feature names to strings in x_test if they are not already
#x_test.columns = x_test.columns.astype(str)
# Proceed with predicting and printing the confusion matrix
y_pred = model.predict(x_test)
cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(cm)

sns.heatmap(cm, annot=True)